<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>V2EX</title><link>https://www.v2ex.com/</link><description>way to explore</description><lastBuildDate>Fri, 16 Aug 2024 12:38:44 GMT</lastBuildDate><generator>rfeed v1.1.1</generator><docs>https://github.com/svpino/rfeed/blob/master/README.md</docs><item><title>[程序员] 有没有开源的 api 聚合系统</title><link>https://www.v2ex.com/t/1065631#reply0</link><description>&lt;p&gt;RT ，目前公司做了不同语言的多个项目，现在准备把这些散落在过个项目中，不同入参、响应规范的基础性服务的 api 接口，聚合在一起，做一套统一的接口服务。&lt;/p&gt;
&lt;p&gt;请教大家，有没有类似开源的项目，做接口聚合的？&lt;/p&gt;</description><pubDate>Fri, 16 Aug 2024 12:34:46 GMT</pubDate><guid isPermaLink="true">https://www.v2ex.com/t/1065631#reply0</guid></item><item><title>[程序员] 重学前端-事件循环</title><link>https://www.v2ex.com/t/1065630#reply0</link><description>&lt;h1&gt;事件循环模型&lt;/h1&gt;
&lt;p&gt;事件循环老生常谈了，社区的相关文章也非常多了，但这次为了彻底搞懂，我深度查看了规范中的规则以及 Chromium 中的源码实现。本文章作为笔记记录。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文主要参考了 &lt;a href="https://www.v2ex.com/#whatwg" rel="nofollow"&gt;&lt;code&gt;WHATWG&lt;/code&gt;&lt;/a&gt; 规范中的定义。建议直接从规范中学习。
各家浏览器对事件循环的具体实现会有细微差别，本文所有代码输出均使用 chrome 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;面试碰到很多问题，比如下面这些，面试官实际上很可能想问的是 &lt;strong&gt;事件循环&lt;/strong&gt;，搞明白了之后就不用害怕被面试官牵着走了，甚至可以主动引导面试官问事件循环。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;什么是进程？什么是线程？&lt;/li&gt;
&lt;li&gt;为什么 js 是异步的？&lt;/li&gt;
&lt;li&gt;说说 Promise 解决了什么问题？&lt;/li&gt;
&lt;li&gt;什么是微任务和宏任务？&lt;/li&gt;
&lt;li&gt;js 引擎执行代码的顺序是什么？&lt;/li&gt;
&lt;li&gt;dom 点击事件中有大量计算后更新 dom ，会有卡死现象如何优化？&lt;/li&gt;
&lt;li&gt;为什么 dom 点击事件中有大量的计算，即使使用异步，还是会影响用户交互操作？&lt;/li&gt;
&lt;li&gt;JS 能实现精准计时器吗？&lt;/li&gt;
&lt;li&gt;如何实现一个尽可能精准的计时器？&lt;/li&gt;
&lt;li&gt;为什么说 js 是事件驱动的？&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;浏览器的进程模型&lt;/h2&gt;
&lt;h3&gt;进程 (Process)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程是一个正在执行的程序的实例。它包含程序代码、数据、资源（如文件、内存）以及执行中的程序计数器、寄存器和堆栈。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;独立性&lt;/strong&gt;：进程是独立的执行单元，拥有自己的内存空间和资源。一个进程不能直接访问另一个进程的内存。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源开销&lt;/strong&gt;：创建和销毁进程的开销较大，因为操作系统需要分配和管理独立的资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;安全性&lt;/strong&gt;：由于进程之间相互独立，不同进程之间的错误不会直接影响彼此，提高了系统的稳定性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;操作系统中的每个运行的应用程序，如文本编辑器、浏览器或计算器，都是一个进程。&lt;/p&gt;
&lt;h3&gt;线程 (Thread)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线程是进程中的一个执行路径，也被称为轻量级进程（ Lightweight Process, LWP ）。一个进程可以包含多个线程，它们共享进程的内存和资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;共享资源&lt;/strong&gt;：同一个进程内的线程共享内存和资源，因此线程间通信和数据共享更加容易和高效。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;开销较小&lt;/strong&gt;：创建和销毁线程的开销比进程小，因为线程之间共享进程的资源。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;并行执行&lt;/strong&gt;：多线程允许一个进程中的多个任务并行执行，从而提高程序的执行效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在一个文本编辑器中，可能会有一个线程负责响应用户输入，另一个线程负责自动保存文档，还有一个线程负责拼写检查。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程与线程的对比&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;进程&lt;/th&gt;
&lt;th&gt;线程&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;内存空间&lt;/td&gt;
&lt;td&gt;独立&lt;/td&gt;
&lt;td&gt;共享进程内存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;创建开销&lt;/td&gt;
&lt;td&gt;大&lt;/td&gt;
&lt;td&gt;小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;通信方式&lt;/td&gt;
&lt;td&gt;通过进程间通信（ IPC ）&lt;/td&gt;
&lt;td&gt;通过共享内存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;崩溃影响&lt;/td&gt;
&lt;td&gt;独立进程崩溃不影响其他进程&lt;/td&gt;
&lt;td&gt;线程崩溃可能导致整个进程崩溃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;执行效率&lt;/td&gt;
&lt;td&gt;较低（独立内存）&lt;/td&gt;
&lt;td&gt;较高（共享内存）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;进程与线程的使用场景&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;进程&lt;/strong&gt;：适用于需要高隔离性和稳定性的任务。例如，操作系统中的不同应用程序通常运行在独立的进程中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程&lt;/strong&gt;：适用于需要高效并行执行且可以共享资源的任务。例如，服务器应用程序中的每个请求可以由一个独立的线程处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;进程&lt;/strong&gt;是操作系统中独立运行的程序实例，拥有独立的内存空间和资源，适用于需要高隔离性和稳定性的任务。创建和销毁进程开销较大，但稳定性高。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程&lt;/strong&gt;是进程中的执行路径，共享进程的内存和资源，适用于需要高效并行执行的任务。线程创建和销毁开销较小，但一个线程崩溃可能影响整个进程。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总结来说，进程提供隔离性和稳定性，而线程提供高效的并行执行能力。&lt;/p&gt;
&lt;h3&gt;浏览器有哪些进程和线程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;浏览器是一个多进程多线程的应用程序&lt;/strong&gt;，而 js 则是单线程的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;主进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;负责浏览器的用户界面（比如浏览器上面的地址栏、前进后退、书签管理等等）、管理各个子进程（管理和创建&lt;strong&gt;渲染进程&lt;/strong&gt;）、处理用户输入以及与操作系统的交互（如文件访问）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;渲染进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每个标签页、iframe 都是一个独立的渲染进程。渲染进程需要处理非常多的任务，譬如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解析 HTML&lt;/li&gt;
&lt;li&gt;构建 DOM 树&lt;/li&gt;
&lt;li&gt;解析 CSS&lt;/li&gt;
&lt;li&gt;计算样式&lt;/li&gt;
&lt;li&gt;计算布局&lt;/li&gt;
&lt;li&gt;页面绘制（重排重绘）&lt;/li&gt;
&lt;li&gt;每秒渲染 60 次页面&lt;/li&gt;
&lt;li&gt;执行 JS 代码，处理宏任务微任务&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;网络进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;专门负责网络请求和资源下载，独立于主进程和渲染进程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;GPU 进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;负责处理图形相关任务，如 3D 绘图和硬件加速，以提高渲染性能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;插件进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;浏览器插件运行在独立的插件进程中，负责处理插件相关的任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;…&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在浏览器的每个渲染进程中，通常包括以下线程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;strong&gt;主线程&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;执行 JavaScript&lt;/li&gt;
&lt;li&gt;处理事件循环&lt;/li&gt;
&lt;li&gt;执行布局和绘制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;渲染线程&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;负责页面的绘制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;合成线程&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;处理 CSS 动画和合成层&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;光栅化线程&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;将合成层转换为位图&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;网络线程&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;处理网络请求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;strong&gt;Worker 线程&lt;/strong&gt;：&lt;ul&gt;
&lt;li&gt;用于 Web Worker 和 Service Worker 的执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;异步编程&lt;/h2&gt;
&lt;p&gt;众所周知，&lt;strong&gt;JavaScript 在浏览器的主线程中是单线程执行的&lt;/strong&gt;。&lt;em&gt;&lt;strong&gt;而异步编程允许代码在不阻塞主线程的情况下执行耗时操作。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;同步编程带来的问题&lt;/h3&gt;
&lt;p&gt;在浏览器环境中，每个标签页都有其独立的渲染进程，其中包含一个主线程负责处理多项任务，如解析 HTML 、构建 DOM 树、解析 CSS 、计算样式和布局、渲染页面以及执行 JavaScript 代码等。&lt;/p&gt;
&lt;p&gt;如果所有这些任务都同步执行，可能会导致以下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;主线程效率低下&lt;/strong&gt;：例如，在等待 AJAX 请求返回结果时，主线程处于空闲状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户体验差&lt;/strong&gt;：长时间的计算或等待可能导致页面无响应，影响交互。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为解决这些问题，浏览器引入了异步编程模型处理各种类型的任务，确保了主线程不会被阻塞，提高了程序的整体效率和响应性。事件循环就是异步的实现方式。&lt;/p&gt;
&lt;h2&gt;JavaScript 中的任务类型&lt;/h2&gt;
&lt;p&gt;同步代码、微任务、宏任务的执行顺序是什么？&lt;/p&gt;
&lt;h3&gt;同步代码&lt;/h3&gt;
&lt;p&gt;在初始阶段，script 标签中的代码被包装称为一个宏任务放到任务队列中，此时是没有其他微任务的。在全局代码中按照出现的顺序立即执行的都是同步代码。&lt;/p&gt;
&lt;p&gt;异步代码则分为微任务和宏任务。&lt;/p&gt;
&lt;h3&gt;微任务&lt;/h3&gt;
&lt;p&gt;在 JavaScript 中，微任务（ Microtasks ）是为了在当前事件循环结束之前执行的小任务。&lt;/p&gt;
&lt;p&gt;微任务在 JavaScript 执行堆栈为空时运行；微任务的执行优先级高于宏任务（ Macrotasks ）。另外，W3C 规范中规定每个渲染进程（标签页或 &lt;strong&gt;Web Worker&lt;/strong&gt; ）中必须且只能有一个微任务队列！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不理解也没关系，只需要记住下面的微任务即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Promise 回调函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;.then()&lt;/code&gt;、&lt;code&gt;.catch()&lt;/code&gt;、&lt;code&gt;.finally()&lt;/code&gt; 注册的&lt;strong&gt;回调函数是微任务&lt;/strong&gt;。但&lt;strong&gt;Promise 本身不是微任务。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如：下面代码中&lt;code&gt;console.log('Promise');&lt;/code&gt; 属于全局同步代码，并不会进入微任务队列！&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-js"&gt;console.log('Script start');

setTimeout(() =&amp;gt; {
    console.log('setTimeout');
}, 0);

new Promise((resolve, reject) =&amp;gt; {
    console.log('Promise');
    resolve();
}).then(() =&amp;gt; {
    console.log('then');
});

// 监听 DOM 变化的回调
const observer = new MutationObserver(() =&amp;gt; {
		// 该回调函数会进入为任务队列
    console.log('MutationObserver');
});
observer.observe(document.querySelector('.box'), {
    attributes: true
});
document.querySelector('.box').setAttribute('data', Math.random());

Promise.resolve()
    .then(() =&amp;gt; {
        console.log('Promise 1');
    })
    .then(() =&amp;gt; {
        console.log('Promise 2');
    });

console.log('Script end');

// 执行结果：
// Script start
// Promise
// Script end
// then
// MutationObserver
// Promise 1
// Promise 2
// setTimeout
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver" rel="nofollow"&gt;MutationObserver&lt;/a&gt; 的回调函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当监听 DOM 变化，其&lt;strong&gt;触发的回调函数是微任务&lt;/strong&gt;。参考上面的代码 &lt;code&gt;console.log('MutationObserver');&lt;/code&gt; 是先进入微任务队列后按队列顺序执行的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide" rel="nofollow"&gt;queueMicrotask&lt;/a&gt; 的回调函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;显式将任务添加到微任务队列。可以用来改变某些代码的执行顺序，但如果增加过多&lt;code&gt;queueMicrotask&lt;/code&gt; ，可能导致其他任务无法执行或延迟， 比如页面渲染任务。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-jsx"&gt;console.log('Script start');

setTimeout(() =&amp;gt; {
    console.log('setTimeout');
}, 0);

new Promise((resolve, reject) =&amp;gt; {
    console.log('Promise');
    resolve();
}).then(() =&amp;gt; {
    console.log('then');
});

// 如果执行下面的无限递归 addMicrotask
// 那么页面上.box textContent 永远也不会变化，渲染 dom 是一个宏任务
// 微任务没有执行完，控制权不会交换给事件循环，因此无法执行宏任务
// function addMicrotask() {
//     queueMicrotask(() =&amp;gt; {
//         console.log('Microtask executed');
//         addMicrotask(); // 继续添加微任务
//     });
// }
// addMicrotask()
queueMicrotask(() =&amp;gt; {
    console.log('Microtask 1');
});

const observer = new MutationObserver(() =&amp;gt; {
    console.log('MutationObserver');
});
observer.observe(document.querySelector('.box'), {
    attributes: true,
});
document.querySelector('.box').textContent = +Date.now();

console.log('Script end');

// 执行结果
// Script start
// Promise
// Script end
// then
// Microtask 1
// setTimeout
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;await&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 &lt;code&gt;await&lt;/code&gt; 时，函数会暂停执行，直到 &lt;code&gt;await&lt;/code&gt; 的 Promise 解决（ fulfilled 或 rejected ）,这段暂停时间允许其他任务执行，不会阻塞主线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当 Promise 解决时，&lt;code&gt;await&lt;/code&gt; 后面的代码会作为微任务加入微任务队列。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;宏任务&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;在最新的 W3C(WHATWG) 规范中，其实并没有宏任务的定义，而是直接称之为“&lt;a href="https://html.spec.whatwg.org/multipage/webappapis.html#concept-task" rel="nofollow"&gt;&lt;strong&gt;任务&lt;/strong&gt;&lt;/a&gt;”，为了容易区分，我们暂时还称为宏任务，但请记住，规范的说法是“&lt;a href="https://html.spec.whatwg.org/multipage/webappapis.html#concept-task" rel="nofollow"&gt;&lt;strong&gt;任务&lt;/strong&gt;&lt;/a&gt;”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;宏任务（ Macrotasks ）同样用于处理异步操作，他和微任务的最大区别在于执行时机，宏任务在微任务之后执行。js 中主要有以下宏任务：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;setTimeout/setInterval 定时器回调函数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Node.js 中的 &lt;strong&gt;setImmediate&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;I/O 操作：&lt;/strong&gt;  处理文件读写、网络请求等输入输出操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UI 渲染：&lt;/strong&gt;  页面绘制、DOM 更新等等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MessageChannel：&lt;/strong&gt;  可以在不同的浏览器上下文之间持续双向通信&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;postMessage：&lt;/strong&gt;  在不同窗口、iframe 、或 worker 之间传递单个消息，单向通信&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;事件回调：&lt;/strong&gt;  绑定到 DOM 事件，如点击、输入等&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;其他特殊任务&lt;/h3&gt;
&lt;p&gt;事实上，还有一些特殊的任务，他们既不是微任务也不是宏任务，有自己独立的运行机制，不适用于常规的事件循环机制，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;requestIdleCallback：&lt;/strong&gt;  在浏览器空闲时执行代码的 API ，优先级较低&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;requestAnimationFrame：&lt;/strong&gt;  浏览器在下一次重绘之前，调用用户提供的回调函数。它的优先级高于宏任务，但低于微任务&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;任务队列&lt;/h2&gt;
&lt;p&gt;任务队列在&lt;a href="https://html.spec.whatwg.org/multipage/webappapis.html#task-queue" rel="nofollow"&gt;规范&lt;/a&gt;中有明确的说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop" rel="nofollow"&gt;事件循环&lt;/a&gt;有一个或多个任务队列。&lt;a href="https://html.spec.whatwg.org/multipage/webappapis.html#task-queue" rel="nofollow"&gt;任务队列&lt;/a&gt;是一&lt;a href="https://infra.spec.whatwg.org/#ordered-set" rel="nofollow"&gt;组&lt;/a&gt;&lt;a href="https://html.spec.whatwg.org/multipage/webappapis.html#concept-task" rel="nofollow"&gt;任务&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;a href="https://html.spec.whatwg.org/multipage/webappapis.html#task-queue" rel="nofollow"&gt;任务队列&lt;/a&gt;是&lt;a href="https://infra.spec.whatwg.org/#ordered-set" rel="nofollow"&gt;集合&lt;/a&gt;，而不是&lt;a href="https://infra.spec.whatwg.org/#queue" rel="nofollow"&gt;队列&lt;/a&gt;，因为&lt;a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" rel="nofollow"&gt;事件循环处理模型&lt;/a&gt;从所选队列中获取第一个&lt;a href="https://html.spec.whatwg.org/multipage/webappapis.html#concept-task-runnable" rel="nofollow"&gt;可运行的&lt;/a&gt;&lt;a href="https://html.spec.whatwg.org/multipage/webappapis.html#concept-task" rel="nofollow"&gt;任务&lt;/a&gt;，而不是使第一个任务&lt;a href="https://infra.spec.whatwg.org/#queue-dequeue" rel="nofollow"&gt;出队&lt;/a&gt;。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;a href="https://html.spec.whatwg.org/multipage/webappapis.html#microtask-queue" rel="nofollow"&gt;微任务队列&lt;/a&gt;不是&lt;a href="https://html.spec.whatwg.org/multipage/webappapis.html#task-queue" rel="nofollow"&gt;任务队列&lt;/a&gt;（这里指的是“宏”任务队列）。&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;微任务队列&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://html.spec.whatwg.org/multipage/webappapis.html#microtask-queue" rel="nofollow"&gt;微任务队列&lt;/a&gt;是当前 JavaScript 主线程中所有微任务的集合。&lt;/strong&gt;&lt;a href="https://html.spec.whatwg.org/multipage/webappapis.html#microtask-queue" rel="nofollow"&gt;规范&lt;/a&gt;要求每个&lt;a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop" rel="nofollow"&gt;事件循环&lt;/a&gt;都有一个微任务队列，最初是空的。&lt;/p&gt;
&lt;p&gt;在所有的同步任务执行完成后，控制权移交事件循环，并获取微任务队列中第一个可运行的任务创建执行上下文后在执行堆栈中运行。&lt;/p&gt;
&lt;h3&gt;任务队列&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;和上面所说的宏任务一样，规范中的准确定义是 &lt;strong&gt;&lt;a href="https://html.spec.whatwg.org/multipage/webappapis.html#task-queue" rel="nofollow"&gt;&lt;code&gt;任务队列&lt;/code&gt;&lt;/a&gt; 。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://html.spec.whatwg.org/multipage/webappapis.html#task-queue" rel="nofollow"&gt;任务队列&lt;/a&gt;是当前 JavaScript 主线程中所有微任务的集合。&lt;/strong&gt; 但和为任务队列不同的是每个事件循环中可以有多个任务队列。&lt;/p&gt;
&lt;p&gt;当页面加载或脚本执行时，最初的同步代码被视为一个宏任务。而此时执行栈是空的，微任务队列也是空的，所以这个“宏任务”会优先执行。&lt;/p&gt;
&lt;p&gt;其他的情况则是按照 &lt;strong&gt;执行同步代码 → 执行微任务 → 执行宏任务&lt;/strong&gt;的顺序。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用定时器无法实现精准的定时效果，给他们传入延时参数只是最快执行的时间，而实际上即使计时到了，也必须等待所有的同步代码和微任务执行完成。
另外，定时器嵌套达到 5 层后会延时参数最小值会强制从 0 变为 4 ，这也增大了误差。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;规范中定义了多个任务的类型，他们有自己关联的任务队列，比如，可能有以下队列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DOM 操作队列：&lt;/strong&gt;  处理 DOM 相关的任务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络事件队列：&lt;/strong&gt;  处理网络请求的响应&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;计时器队列：&lt;/strong&gt;  处理 &lt;code&gt;setTimeout&lt;/code&gt; 和 &lt;code&gt;setInterval&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用户交互队列：&lt;/strong&gt;  处理用户输入事件，如点击和键盘输入。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;渲染队列：&lt;/strong&gt;  处理与页面渲染相关的任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多个任务队列如何保证执行顺序？通常来说是按照进入队列的时间，不过规范中并没有严格定义，允许各家浏览器自行实现内部细节，但用户交互相关任务（如鼠标点击、键盘输入等）的优先级会较高一些，以确保用户操作的响应速度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;规范中的原文如下：
For example, a user agent could have one &lt;a href="https://html.spec.whatwg.org/multipage/webappapis.html#task-queue" rel="nofollow"&gt;task queue&lt;/a&gt; for mouse and key events (to which the &lt;a href="https://html.spec.whatwg.org/multipage/webappapis.html#user-interaction-task-source" rel="nofollow"&gt;user interaction task source&lt;/a&gt; is associated), and another to which all other &lt;a href="https://html.spec.whatwg.org/multipage/webappapis.html#task-source" rel="nofollow"&gt;task sources&lt;/a&gt; are associated. Then, using the freedom granted in the initial step of the &lt;a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" rel="nofollow"&gt;event loop processing model&lt;/a&gt;, it could give keyboard and mouse events preference over other tasks three-quarters of the time, keeping the interface responsive but not starving other task queues. Note that in this setup, the processing model still enforces that the user agent would never process events from any one &lt;a href="https://html.spec.whatwg.org/multipage/webappapis.html#task-source" rel="nofollow"&gt;task source&lt;/a&gt; out of order.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;strong&gt;任务派发流程&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在浏览器环境中，虽然 JavaScript 是单线程执行的，但每个渲染进程（如每个 Tab 或 Worker ）由多个线程组成。这些线程包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主线程（ UI 线程）&lt;/strong&gt;：执行 JavaScript 、布局、绘制等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;合成线程：&lt;/strong&gt;  处理页面合成和光栅化。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作线程（ Web Workers ）&lt;/strong&gt;：包括 Web Workers 和其他后台任务处理线程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IO 线程：&lt;/strong&gt;  处理 IPC 通信和网络请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;定时器线程&lt;/strong&gt;：处理定时任务（如 &lt;code&gt;setTimeout&lt;/code&gt;、&lt;code&gt;setInterval&lt;/code&gt;）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 JavaScript 代码在主线程的执行栈中运行时，遇到异步 API （如定时器、网络请求、事件监听器等）会触发任务分发：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定时器任务：&lt;/strong&gt;  由定时器线程管理，到期后将回调函数封装为任务，放入任务队列。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络请求：&lt;/strong&gt;  由 IO 线程处理，完成后将回调封装为任务，加入网络任务队列。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DOM 事件：&lt;/strong&gt;  由主线程监听，事件触发时将监听器封装为任务，加入事件任务队列。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Promise 微任务：&lt;/strong&gt;  在当前执行栈清空后，主线程立即处理这些微任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来等待&lt;strong&gt;事件循环&lt;/strong&gt;处理任务队列即可。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器内部会有一套非常复杂的逻辑用于管理不同优先级的任务队列，例如 chromium 中的 &lt;a href="https://github.com/chromium/chromium/blob/d53578e9ef7779254dc7b5681a339c75bbf2e234/base/task/sequence_manager/README.md" rel="nofollow"&gt;sequence_manger&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;事件循环&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在 w3c 标准中称为&lt;a href="https://www.w3.org/TR/2011/WD-html5-20110525/webappapis.html#event-loops" rel="nofollow"&gt;&lt;strong&gt;&lt;code&gt;Event loops&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt; ，而在谷歌的 chromium 中称为 &lt;code&gt;Message Loop&lt;/code&gt; ，源码中具体的实现方法是&lt;a href="https://github.com/chromium/chromium/blob/main/base/message_loop/message_pump_default.cc#L32C6-L32C29" rel="nofollow"&gt;&lt;code&gt;MessagePumpDefault::Run&lt;/code&gt;&lt;/a&gt; ，参考以下代码：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="language-cpp"&gt;    void MessagePumpDefault::Run(Delegate* delegate) {
      // 通过 AutoReset 类自动管理 keep_running_的值。构造函数将 keep_running_设置为 true ，
      // 析构函数将其恢复为原来的值。
      AutoReset&amp;lt;bool&amp;gt; auto_reset_keep_running(&amp;amp;keep_running_, true);

      // 无限循环，直到 keep_running_被设置为 false 或遇到 break 语句。
      for (;;) {
    #if BUILDFLAG(IS_APPLE)
        // 在 Apple 平台上，创建一个自动释放池（ autorelease pool ），
        // 用于管理 Objective-C 对象的内存。
        apple::ScopedNSAutoreleasePool autorelease_pool;
    #endif

        // 调用 delegate 的 DoWork 方法获取下一步工作的信息。
        Delegate::NextWorkInfo next_work_info = delegate-&amp;gt;DoWork();
        // 检查是否有更多的紧急工作需要立即处理。
        bool has_more_immediate_work = next_work_info.is_immediate();
        // 如果 keep_running_被设置为 false ，退出循环。
        if (!keep_running_)
          break;

        // 如果有更多的紧急工作，继续循环处理，而不进行等待。
        if (has_more_immediate_work)
          continue;

        // 调用 delegate 的 DoIdleWork 方法，处理空闲时的工作。
        delegate-&amp;gt;DoIdleWork();
        // 再次检查 keep_running_，如果为 false ，则退出循环。
        if (!keep_running_)
          break;

        // 根据 next_work_info 中的信息决定是否进行等待。
        if (next_work_info.delayed_run_time.is_max()) {
          // 如果 next_work_info.delayed_run_time 为最大值，
          // 则进行无限等待，直到 event_被触发。
          event_.Wait();
        } else {
          // 否则，等待指定的时间（ remaining_delay ）后再继续。
          event_.TimedWait(next_work_info.remaining_delay());
        }
        // Since event_ is auto-reset, we don't need to do anything special here
        // other than service each delegate method.
        // event_是自动重置的，因此我们不需要在这里做特殊处理。
        // 只需要继续服务每个 delegate 的方法。
      }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;了解上面的内容后，事件循环就非常容易理解了。&lt;strong&gt;整体流程如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;主线程运行全局/局部同步代码，同时处理微任务队列和任务队列&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;同步代码执行完成通知事件循环启动并查询微任务队列中第一个可运行的任务交由执行栈运行代码，直至微任务队列为空&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;查询其他任务队列，取出第一个可运行任务交由执行栈运行代码&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;宏任务中可能存在同步代码或微任务，重复 1-4 ，直至任务队列全部清空&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="https://fastly.jsdelivr.net/gh/rennzhang/blog-pics@main/images/1723099122073%E7%94%BB%E5%B8%83%E4%B8%80.png 转存失败，建议直接上传图片文件" class="embedded_image" rel="noreferrer" src="https://fastly.jsdelivr.net/gh/rennzhang/blog-pics@main/images/1723099122073%E7%94%BB%E5%B8%83%E4%B8%80.png" /&gt;&lt;/p&gt;
&lt;p&gt;Javascript 是事件驱动的。&lt;/p&gt;
&lt;h2&gt;代码输出顺序&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;下面这道地狱级别输出题，能答对 70%我相信就能应对大部分面试官了🤓（可以去掉&lt;strong&gt;requestAnimationFrame 和 requestIdleCallback ，这两个干扰比较大&lt;/strong&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;这个案例中从输出结果来看 channel.port2.postMessage 的优先级似乎比 settimeout 要低一些，并没有严格按照代码出现顺序执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang="en"&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;meta charset="UTF-8" /&amp;gt;
    &amp;lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&amp;gt;
    &amp;lt;title&amp;gt;Macro and Microtasks&amp;lt;/title&amp;gt;
    &amp;lt;style&amp;gt;&amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;textarea name="" id=""&amp;gt;&amp;lt;/textarea&amp;gt;
    &amp;lt;div class="box"&amp;gt;&amp;lt;/div&amp;gt;

    &amp;lt;script&amp;gt;
        console.log("1");

        setTimeout(() =&amp;gt; {
            console.log("2");
        }, 0);

        setTimeout(() =&amp;gt; {
            console.log("3");
        }, 1000);

        const channel = new MessageChannel();
        channel.port1.onmessage = (val) =&amp;gt; {
            console.log(val);
        };
        channel.port2.postMessage("4");

        setInterval(() =&amp;gt; {
            console.log("55");
        }, 1000);

        let a = 1;
        while (a &amp;lt; 100000) {
            a++;
            if (a == 1000 || a == 100000) console.log(a);
        }

        new Promise(function (resolve, reject) {
            console.log("5");
            resolve(3);
        }).then(function (val) {
            console.log("6");
        });
        console.log(7);

        Promise.resolve()
            .then(() =&amp;gt; {
                console.log("8");
            })
            .then(() =&amp;gt; {
                console.log("9");
            });

        const observer = new MutationObserver(() =&amp;gt; {
            console.log("MutationObserver 10");
        });
        observer.observe(document.querySelector(".box"), {
            attributes: true,
        });
        document.querySelector(".box").setAttribute("data", Math.random());
        setTimeout(() =&amp;gt; {
            console.log("11");
            Promise.resolve().then(() =&amp;gt; {
                console.log("12");
            });
            requestAnimationFrame(() =&amp;gt; {
                console.log("RAF 13");
            });
        }, 0);

        console.log("14");
        requestIdleCallback(() =&amp;gt; {
            console.log("requestIdleCallback 15");
        });

        queueMicrotask(() =&amp;gt; {
            console.log("16");
            new Promise((resolve, reject) =&amp;gt; {
                console.log("17");
                resolve();
            }).then(() =&amp;gt; {
                console.log("18");
            });
            Promise.resolve()
                .then(() =&amp;gt; {
                    console.log("19");
                })
                .then(() =&amp;gt; {
                    console.log("20");
                });

            setTimeout(() =&amp;gt; {
                console.log("21");
            }, 0);

            requestAnimationFrame(() =&amp;gt; {
                console.log("RAF 22");
            });
        });

        Promise.resolve()
            .then(() =&amp;gt; {
                console.log("23");
            })
        channel.port2.postMessage("24");

        requestAnimationFrame(() =&amp;gt; {
            console.log("RAF 25");
        });

        console.log("26");
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
&lt;h3&gt;WHATWG&lt;/h3&gt;
&lt;p&gt;虽然 W3C 曾是 Web 标准的主要制定者，但在 HTML 方面，WHATWG 的“Living Standard”模式更适合快速变化的 Web 环境。W3C 的标准更新较慢，可能无法及时反映最新的技术和浏览器实现。最重要的是，各大浏览器厂商通常使用 WHATWG 的规范来实现 HTML 和 DOM 标准。&lt;/p&gt;
&lt;h3&gt;资料列表&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop" rel="nofollow"&gt;事件循环 - HTML Standard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://html.spec.whatwg.org/multipage/webappapis.html#task-queue" rel="nofollow"&gt;任务队列 - HTML Standard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://html.spec.whatwg.org/multipage/webappapis.html#generic-task-sources" rel="nofollow"&gt;任务源类型 - HTML Standard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" rel="nofollow"&gt;事件循环执行步骤 - HTML Standard&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth" rel="nofollow"&gt;深入：微任务与 Javascript 运行时环境 - Web API | MDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Event_loop" rel="nofollow"&gt;并发模型与事件循环 - JavaScript | MDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide#%E4%BB%BB%E5%8A%A1_vs_%E5%BE%AE%E4%BB%BB%E5%8A%A1" rel="nofollow"&gt;在 JavaScript 中通过 queueMicrotask() 使用微任务 - Web API | MDN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/document/u/0/d/1iugySsfTXtSg4cBwAarhObu89392hYZp-119x7inhR0/mobilebasic?_immersive_translate_auto_translate=1" rel="nofollow"&gt;base::CurrentTaskRunner 提案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://chromium.googlesource.com/chromium/src/+/main/docs/threading_and_tasks.md#Posting-to-the-Current-Virtual_Thread" rel="nofollow"&gt;Chromium Docs - Threading and Tasks in Chrome&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/chromium/chromium/blob/d53578e9ef7779254dc7b5681a339c75bbf2e234/base/task/sequence_manager/README.md" rel="nofollow"&gt;chromium/base/task/sequence_manager/README.md · chromium/chromium&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://javascript.plainenglish.io/how-the-event-loop-works-in-the-chrome-browser-ccf99c6c5a5" rel="nofollow"&gt;Chrome 浏览器中的事件循环工作原理 | 作者：Roman Melnik&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://cycle263.github.io/blogs/javascripts/depth/async/thread.html" rel="nofollow"&gt;浏览器线程 | Cycle263 Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description><pubDate>Fri, 16 Aug 2024 12:22:25 GMT</pubDate><guid isPermaLink="true">https://www.v2ex.com/t/1065630#reply0</guid></item><item><title>[宽带症候群] pt 站点疑似有 pcdn 用户出现</title><link>https://www.v2ex.com/t/1065628#reply4</link><description>&lt;p&gt;目前只在 hdtime 和 hdfans 上发现，下载到 100%后，过一天又会重新开始下载
183.130.207.228
183.130.235.175
115.221.106.105
115.219.5.10
220.190.36.23
115.222.156.94
这几个 ip 可以肯定是 pcdn 刷流量的
而且都是温州的，不知道是不是巧合&lt;/p&gt;</description><pubDate>Fri, 16 Aug 2024 12:03:10 GMT</pubDate><guid isPermaLink="true">https://www.v2ex.com/t/1065628#reply4</guid></item><item><title>[macOS] macOS 不允许分配 Shift 键作为快捷键的一部分是有什么原因吗？</title><link>https://www.v2ex.com/t/1065627#reply1</link><description>作为一个平时不只使用英语作为唯一输入法的人，多年以来我始终感觉独自决定使用“单次按大小写锁定键切换输入法”的逻辑非常的离谱，他们难道没有发现左手的小拇指只要轻轻向下移到左 Shift 键上，轻按，这样更符合逻辑同时也不会不舒适么？或者 Shift+空格键也可以。&lt;br /&gt;&lt;br /&gt;但是如果要去碰键盘最下面一排空格键左边的那几个键，我就不得不用我的胳膊肘带动左手腕移动我左手掌的位置去切换输入法，再回到传统按键区（ ASDF ）继续输入文字。在我的左手在 ASDF 键位上时，不太费力可以碰到的左边的键只有大小写锁定键和左 Shift 键（当然也有 Tab 键，但是在输入文字时单击它有它自己的功能，而单击 Shift 通常没有）。&lt;br /&gt;&lt;br /&gt;我不觉得只有我一个人给写 feedback 会引起他们的注意，所以只是吐槽一下</description><pubDate>Fri, 16 Aug 2024 11:57:23 GMT</pubDate><guid isPermaLink="true">https://www.v2ex.com/t/1065627#reply1</guid></item><item><title>[投资] 今天接到 HSBC RM 的电话，建议我投资美股和美债</title><link>https://www.v2ex.com/t/1065626#reply3</link><description>&lt;p&gt;各位有什么推荐？是直接买股/债，还是买 ETF ？&lt;/p&gt;
&lt;p&gt;预计 9 月降息后美元汇率会跌，现在换美元会不会亏？&lt;/p&gt;</description><pubDate>Fri, 16 Aug 2024 11:52:51 GMT</pubDate><guid isPermaLink="true">https://www.v2ex.com/t/1065626#reply3</guid></item><item><title>[分享创造] 重新做了个人主页和导航站，感觉比以前顺眼多了。再顺便加个文件分享</title><link>https://www.v2ex.com/t/1065625#reply1</link><description>&lt;p&gt;之前的主页和导航站一直是静态的，要改个东西还要用 vim 改。&lt;/p&gt;
&lt;p&gt;考虑到之前总是需要传小文件，登微信又不方便，需要一个文件分享功能。&lt;/p&gt;
&lt;p&gt;有些时候一些链接特别长，发给别人一大串，再做个短链服务吧。&lt;/p&gt;
&lt;p&gt;做都做了，再顺手一个 markdown 的笔记（这个功能有点简陋）。&lt;/p&gt;
&lt;h2&gt;功能介绍&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;首页个人信息与横幅展示&lt;/li&gt;
&lt;li&gt;导航页的外链展示与跳转&lt;/li&gt;
&lt;li&gt;
账号密码登录&lt;ul&gt;
&lt;li&gt;在主页单击名字，账号密码输入框会弹出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;云笔记模块&lt;/li&gt;
&lt;li&gt;短链服务&lt;/li&gt;
&lt;li&gt;文件存储/分享/直链下载/鉴权&lt;/li&gt;
&lt;li&gt;着陆页的所有内容可编辑&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="着陆页首屏" class="embedded_image" rel="noreferrer" src="https://raw.githubusercontent.com/Coooolfan/UniBoard/v0.2.1/img/LandingPage1.png" /&gt;
&lt;img alt="着陆页第二屏" class="embedded_image" rel="noreferrer" src="https://raw.githubusercontent.com/Coooolfan/UniBoard/v0.2.1/img/LandingPage2.png" /&gt;
&lt;img alt="主页功能组件展示" class="embedded_image" rel="noreferrer" src="https://raw.githubusercontent.com/Coooolfan/UniBoard/v0.2.1/img/HomePage.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;第一方支持 docker-compose 部署，编辑完&lt;code&gt;.env&lt;/code&gt;一行命令就可以启动体验一下&lt;/p&gt;
&lt;p&gt;再说一下这个文件分享，我自己还挺喜欢的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以生成 5 分钟有效的直链&lt;/li&gt;
&lt;li&gt;可以设置分享密码、附言&lt;/li&gt;
&lt;li&gt;非私有的文件也可以用 api 直接下载。直接 wget 就行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;项目地址：&lt;a href="https://github.com/Coooolfan/UniBoard" rel="nofollow"&gt;https://github.com/Coooolfan/UniBoard&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;后续应该还会集成一个探针服务，嘻嘻。有灵感的时候写代码好爽的&lt;/p&gt;</description><pubDate>Fri, 16 Aug 2024 11:52:42 GMT</pubDate><guid isPermaLink="true">https://www.v2ex.com/t/1065625#reply1</guid></item><item><title>[酷工作] 招聘高级 golang 开发 30-35k，远程办公 [要有游戏和区块链经验]</title><link>https://www.v2ex.com/t/1065623#reply0</link><description>&lt;p&gt;职责描述&lt;/p&gt;
&lt;p&gt;• Golang 工程师 [ 30-35k ]&lt;/p&gt;
&lt;p&gt;1.负责游戏服务端、虚拟币钱包、区块链的开发工作&lt;/p&gt;
&lt;p&gt;2.负责项目的整体框架构建&lt;/p&gt;
&lt;p&gt;3.通过数据分析项目系统性能，对整个系统进行深度优化，提高性能和稳定性&lt;/p&gt;
&lt;p&gt;4.有区块链应用、Telegram 机器人、棋牌游戏服务端开发经验者优先&lt;/p&gt;
&lt;p&gt;有意者可以联系发简历到邮箱： &lt;a href="mailto:luluyaya@proton.me"&gt;luluyaya@proton.me&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简历留下你的 Telegram 如果合适会有专人联系你的&lt;/p&gt;</description><pubDate>Fri, 16 Aug 2024 11:48:39 GMT</pubDate><guid isPermaLink="true">https://www.v2ex.com/t/1065623#reply0</guid></item><item><title>[求职] web3 有没有新人友好岗位</title><link>https://www.v2ex.com/t/1065622#reply0</link><description>&lt;p&gt;最近正在学习 web3 。苦于没有经验，找不到合适的岗位来对标学习。这个问题如何破解&lt;/p&gt;</description><pubDate>Fri, 16 Aug 2024 11:44:11 GMT</pubDate><guid isPermaLink="true">https://www.v2ex.com/t/1065622#reply0</guid></item><item><title>[宽带症候群] 谁偷了我的🪜流量？分享一个自用的全屋科学监控面板</title><link>https://www.v2ex.com/t/1065621#reply1</link><description>&lt;p&gt;&lt;a href="https://www.v2ex.com/t/1039732" rel="nofollow"&gt;书接上回&lt;/a&gt;，自从手搓完 OSPF 域名分流方案，并分享出来后，得益于用户反馈，修复了不少小问题，也提升了不少实用性。&lt;/p&gt;
&lt;p&gt;主要包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修复了多个出口时 conn-track 可能未按预期工作的 bug&lt;/li&gt;
&lt;li&gt;添加了 balancer 支持，现在可以使用负载均衡作为路由出口决策，并且同时支持 conn-track&lt;/li&gt;
&lt;li&gt;添加了新的 outbound stats 统计，可用于精确观测出口流量状况&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;杂项修复&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修正了文档里的部署网段需求，现在要求主/旁路由处于一个独立的网段&lt;/li&gt;
&lt;li&gt;文档添加了负载均衡和连接观测的示例配置&lt;/li&gt;
&lt;li&gt;修复一个上游 bug 导致 leastping balancer fallbackTag 无法使用的问题&lt;/li&gt;
&lt;li&gt;修正了之前 ROS 配置不当导致 WAN 口可接受 DNS 查询的问题（上海电信居然没封家宽 53 端口）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;虽然我用的是黑名单分流，但由于是全屋科学方案，仍然比较尴尬的发现，上个月还剩一周的时候我的魔法流量已经见底了。&lt;/p&gt;
&lt;p&gt;所以，结合我现在已有的 Prometheus 监控方案（用于监控 Mikrotik/Synology/全屋温湿度等），自然是考虑把 v2ray 也接入进来。一通捣鼓后就有了这个帖子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;必须要逮住这个偷跑我流量的耗子（&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实现过程，大概是，借助现有的 v2ray-exporter ，将 v2ray 的 stats api 数据导出并转换为 Prometheus Counter metric ，顺带再魔改了一下 outbound stats ，添加了来源 IP 的 label ，这下可以精确到每一个终端的实时魔法流量情况和消耗统计了。结合 accessLog 应该就可以最终定位是谁在偷我流量啦。&lt;/p&gt;
&lt;p&gt;fork 并修改后的 exporter 项目如下（感谢原作者 wi1dcard ）&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/povsister/v2ray-exporter" rel="nofollow"&gt;povsister/v2ray-exporter&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;README 也已按需修改，有 prometheu 部署经验的可直接食用。
Release 里提供了预编译好的常见平台可执行文件，可按需下载。&lt;/p&gt;
&lt;p&gt;预览图如下&lt;/p&gt;
&lt;p&gt;&lt;img alt="dash1" class="embedded_image" rel="noreferrer" src="https://i.imgur.com/fWL1h5Y.png" /&gt;
&lt;img alt="dash2" class="embedded_image" rel="noreferrer" src="https://i.imgur.com/72BlCeP.png" /&gt;&lt;/p&gt;</description><pubDate>Fri, 16 Aug 2024 11:41:23 GMT</pubDate><guid isPermaLink="true">https://www.v2ex.com/t/1065621#reply1</guid></item><item><title>[酷工作] 苏州徕卡显微系统招人啦</title><link>https://www.v2ex.com/t/1065620#reply1</link><description>&lt;p&gt;需求如下: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三年以上 c++经验 &lt;/li&gt;
&lt;li&gt;本科以上学历&lt;/li&gt;
&lt;li&gt;工作比较稳定（跳槽不频繁）&lt;/li&gt;
&lt;li&gt;能在苏州长住（团队需要稳定）&lt;/li&gt;
&lt;li&gt;希望不要那么卷（不打黑工，到点就走）（这点是我加的）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;工作内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主要技术栈是桌面端软件 Qt/Qml ，目前主要是 Windows,Linux.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;加分项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;女生（女生在面试过程中享有巨大优势，并且公司男女比例较均衡）&lt;/li&gt;
&lt;li&gt;硕士（可能会帮助后期筛选）&lt;/li&gt;
&lt;li&gt;能来苏州进行面试&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;内推缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面试周期较长，需要等待&lt;/li&gt;
&lt;li&gt;会有简单笔试（ maybe ）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;福利: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;12 年假+10 病假 &lt;/li&gt;
&lt;li&gt;一定比例居家办公（目前是一年 24 天，具体看情况）&lt;/li&gt;
&lt;li&gt;wlb ，不打卡，永不加班 &lt;/li&gt;
&lt;li&gt;公积金 12%&lt;/li&gt;
&lt;li&gt;享受最棒的团队氛围，manager 也非常棒。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;薪资:
需要跟 HR 谈，所以给不了大家。(相对一线城市和大厂，可能没有那么有竞争力)&lt;/p&gt;
&lt;p&gt;有兴趣，可以私我:（节省大家的时间，不符合要求勿扰，谢谢大家） 绿色软件:bGlnaWdneQ==&lt;/p&gt;
&lt;p&gt;一年前已经内推过一位了，并且得到了一致好评。&lt;/p&gt;</description><pubDate>Fri, 16 Aug 2024 11:30:10 GMT</pubDate><guid isPermaLink="true">https://www.v2ex.com/t/1065620#reply1</guid></item><item><title>[反馈] 报告用户 maybeok</title><link>https://www.v2ex.com/t/1065619#reply0</link><description>用户首页： &lt;a href="https://www.v2ex.com/member/maybeok" rel="nofollow noopener" target="_blank"&gt;https://www.v2ex.com/member/maybeok&lt;/a&gt; &lt;br /&gt; 该用户涉及 疑似机器帐号，请站长请处理</description><pubDate>Fri, 16 Aug 2024 10:52:14 GMT</pubDate><guid isPermaLink="true">https://www.v2ex.com/t/1065619#reply0</guid></item><item><title>[Apple] Apple Watch esim 值不值得开</title><link>https://www.v2ex.com/t/1065617#reply4</link><description>&lt;p&gt;之前一直没买过带 esim 的表，最近换新了，现在在考虑要不要开通 esim 。&lt;br /&gt;
我考虑了一下使用场景，我也没有出门跑步的需求，其他场景好像就用不到 esim 了。&lt;br /&gt;
求指点。&lt;/p&gt;</description><pubDate>Fri, 16 Aug 2024 10:37:48 GMT</pubDate><guid isPermaLink="true">https://www.v2ex.com/t/1065617#reply4</guid></item><item><title>[程序员] 个人项目前端好看的组件库推荐</title><link>https://www.v2ex.com/t/1065616#reply1</link><description>&lt;p&gt;在写个人项目，前端比较菜，有没有大佬推荐下好看的前端组件库。本来用的 element plus ，这玩意儿看着觉得很一般，太通用了。希望炫酷或者优美好看点的。涉及到的组件有通知组件，加载组件，还有些弹窗的组件。&lt;/p&gt;</description><pubDate>Fri, 16 Aug 2024 10:35:10 GMT</pubDate><guid isPermaLink="true">https://www.v2ex.com/t/1065616#reply1</guid></item><item><title>[问与答] 谷歌邮箱网页版，居然将广告插到邮件列表里</title><link>https://www.v2ex.com/t/1065615#reply0</link><description>&lt;p&gt;谷歌邮箱网页版，居然将广告插到邮件列表里&lt;/p&gt;
&lt;p&gt;并且这些广告还加在收件箱的计数里面，全部已读功能也无效，必须点击才能查看才清楚未读，删除也只能一条一条删除
&lt;a href="https://sm.ms/image/Ri3wCMmrUol8BX6" rel="nofollow"&gt;&lt;img class="embedded_image" rel="noreferrer" src="https://s2.loli.net/2024/08/16/Ri3wCMmrUol8BX6.jpg" /&gt;&lt;/a&gt;&lt;/p&gt;</description><pubDate>Fri, 16 Aug 2024 10:28:51 GMT</pubDate><guid isPermaLink="true">https://www.v2ex.com/t/1065615#reply0</guid></item><item><title>[Chrome] 如何让 Chrome 保持账号登录但是 google.com 不登录</title><link>https://www.v2ex.com/t/1065614#reply1</link><description></description><pubDate>Fri, 16 Aug 2024 10:22:54 GMT</pubDate><guid isPermaLink="true">https://www.v2ex.com/t/1065614#reply1</guid></item><item><title>[问与答] 这几天 play 商店更新不了 app</title><link>https://www.v2ex.com/t/1065613#reply1</link><description>play 商店版本 42.3.20-23&lt;br /&gt;&lt;br /&gt;这几天怎么更新不了 app ，转圈圈。</description><pubDate>Fri, 16 Aug 2024 10:22:10 GMT</pubDate><guid isPermaLink="true">https://www.v2ex.com/t/1065613#reply1</guid></item><item><title>[移民] 大龄留学移民，选蒙特利尔还是新加坡</title><link>https://www.v2ex.com/t/1065612#reply1</link><description>各位 V 友大家好，楼主今年 36 岁，不是程序员，是在非洲最穷的地方搞基建的。因为是在法语区国家，去年一位同事移民去了魁北克，说那边对孩子教育很友好。所以楼主也动了心思，2 月份考了雅思，口语拉跨只有 5.5 ，总分 7 。看了一圈学校，不卡小分的比较少，4 月初申请了温莎、渥太华、麦马、康考迪亚的工程硕士。温莎和渥太华很快就发了拒信，康考迪亚 7 月初发了 offer ，麦马还没信儿，估计是没戏（本科专业不是很对口，GPA 也不高）。&lt;br /&gt;  &lt;br /&gt;　　 7 月份看南洋理工也有招生，也去申了一个土木工程管理类的硕士，咔咔面试一通，今天下了 offer ，让下周一之前交 5000 新币的占位费。&lt;br /&gt;  &lt;br /&gt;　　楼主很纠结，南洋理工是高中时的梦中情校，QS 排名 10 左右，康考迪亚都 400 了，出了魁北克可能都没人知道这学校。&lt;br /&gt;  &lt;br /&gt;　　楼主的目的是移民，新加坡的话，毕业后给一年的 LTVP 用来找工作，工程类工作也好找，东南亚基建大市场，但是新加坡对大龄不是很友好，工程类的工资也不会特别高，所以拿永居可能有点危险。优点是一年读出来，时间短，华人友好，整体环境安全，离家近，机票钱和高铁差不多，没有身份的话孩子上国际学校学费贵，但能 cover 住。&lt;br /&gt;  &lt;br /&gt;　　蒙特利尔的话，读一年半到两年，毕业后给 3 年工签，但是今年政策变了，康考迪亚是英语学校，读出了不能走学生类 PEQ 了，只能工作两年再申请经验类 PEQ ，还要把法语考出来，另外 PEQ 可能一年还下不来，到时候要做过桥工签。这样的话在那边待 5-6 年才能拿到身份。蒙特利尔的房租和生活成本不高，回国机票贵，冬季有点冷，华人少一些，法语民族大熔炉，白人可能有点歧视，社会治安中等吧，听说偷车也很严重（卖给非洲这边黑兄弟）。&lt;br /&gt;  &lt;br /&gt;      家里的话，媳妇带着孩子，要等我拿到身份可能才会跟我出来，怕拿不到身份没有后路。&lt;br /&gt;  &lt;br /&gt;　　楼主家境普通，自小单亲家庭，什么事情都是自己做主，也没人指导，没啥见识。论坛的宝子们，你们出去的多，见识广，帮忙看看给个建议。</description><pubDate>Fri, 16 Aug 2024 10:15:22 GMT</pubDate><guid isPermaLink="true">https://www.v2ex.com/t/1065612#reply1</guid></item><item><title>[求职] 杭州求职， 10 年 Android 经验</title><link>https://www.v2ex.com/t/1065611#reply1</link><description>在团队负责核心业务开发和性能优化相关工作，有多个完整项目开发迭代经验，同时负责团队 Android 端广告 SDK 开发工作&lt;br /&gt;Kotlin/JetPackCompose 都熟练掌握，谋求杭州 Android 岗位开发工作。</description><pubDate>Fri, 16 Aug 2024 10:11:05 GMT</pubDate><guid isPermaLink="true">https://www.v2ex.com/t/1065611#reply1</guid></item><item><title>[分享创造] chrome 插件 抖音视频下载助手</title><link>https://www.v2ex.com/t/1065610#reply1</link><description>&lt;div class="embedded_video_wrapper"&gt;&lt;/div&gt;&lt;br /&gt;&lt;a href="https://chrome.google.com/webstore/detail/nkffbmomkmgaoogcenpadgmclfnjjfbk" rel="nofollow noopener" target="_blank"&gt;https://chrome.google.com/webstore/detail/nkffbmomkmgaoogcenpadgmclfnjjfbk&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;自己写了个 chrome 插件， 一键下载抖音美女视频&lt;br /&gt;欢迎各位老板使用</description><pubDate>Fri, 16 Aug 2024 10:11:04 GMT</pubDate><guid isPermaLink="true">https://www.v2ex.com/t/1065610#reply1</guid></item><item><title>[分享创造] 上线了基于 Flux 实现的 Grok AI 图片生成工具</title><link>https://www.v2ex.com/t/1065607#reply0</link><description>&lt;p&gt;这两天 Grok 又放出了新功能，Grok 的图片生成器，初步体验，真的很 Flux 效果很相似，参考他们的方案，我们基于 Flux 也上线了这个&lt;a href="https://https://grokimagegenerator.net/" rel="nofollow"&gt;Grok AI 图像工具&lt;/a&gt;. 考虑能够快速上线和给用户比较好的体验，工具会比较简单。
现在有提供试用功能，欢迎大家体验！&lt;/p&gt;</description><pubDate>Fri, 16 Aug 2024 10:07:40 GMT</pubDate><guid isPermaLink="true">https://www.v2ex.com/t/1065607#reply0</guid></item></channel></rss>